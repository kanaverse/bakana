# Adding custom readers

## Overview

Developers can add new result readers to supplement the defaults in `src/readers`.
Unlike datasets, result structures are expected to contain pre-computed analysis results from steps like clustering and dimensionality reduction;
there is no expectation that the count matrix is present, nor any requirement for particular modalities.
A new reader should be implemented as an ES6 class that satisfies the `Result` interface requirements below.

It's worth mentioning that only `Dataset` objects are used as inputs into the **bakana** analysis.
`Result` objects do not have any role in **bakana**; but we describe them here regardless,
as each `Result` class tends to share a lot of code with the corresponding `Dataset` class.
This allows downstream applications to re-use a lot of the same code when inspecting results from the same file format as the input datasets.

## `Result` interface

### Constructor

Each `Result` instance is constructed by users before entry into the **bakana** workflow.
Thus, **bakana** itself does not have any particular expectations on the form of the constructor.
There are, however, a few conventions:

- For consistency with the existing `Result` readers, developers of new file-based readers should consider accepting [`SimpleFile`](https://ltla.github.io/bakana/SimpleFile.html) objects.
  This provides a convenient abstraction for files in Node.js and browser contexts.
- Constructors are expected to be cheap to run.
  Any complex initialization should be deferred until it is needed, e.g., in `summary()` or `load()`.
- Optional parameters can be passed via an `options=` object in the constructor.
  Some sensible defaults can be specified via destructuring.

### `summary({ cache = false } = {})`

This method should return an object containing an appropriate summary of this dataset.
The object may contain any number of the following properties:

- `all_features`: a [`DataFrame`](https://ltla.github.io/bioconductor.js/DataFrame.html) containing per-feature annotations.
  Each row of the `DataFrame` corresponds to one feature, along with any number of columns containing the annotation fields.
- `modality_features`: an object where each key is the name of a modality and each value is a `DataFrame`.
  Each row of a `DataFrame` corresponds to one feature of the corresponding modality and contains its annotation fields.
- `cells`: a `DataFrame` containing per-cell annotations, where each row corresponds to a cell in the dataset.
- `all_assay_names`: an Array containing the names of all assays.
- `modality_assay_names`: an object where each key is the name of a modality and each value is an Array.
  Each Array contains the names of the assays for that modality.
- `reduced_dimension_names`: an Array containing the names of all dimensionality reduction results.
- `other_metadata`: an object containing additional arbitrary metadata for the `Result`.

Alternatively, this method may return a promise that resolves to such an object.

If `cache = true`, any artifacts generated by `summary()` may be cached for re-use in the subsequent calls to the same method or `load()`.
This allows for faster repeated calls at the cost of increasing memory usage.
If `cache = false`, no caching should be performed and any previously cached artifacts should be removed.

Note that the return value of `summary()` is expected to be constant for the same `Result` instance.
It should not be affected by any setters; rather, setters are expected to be called based on the `summary()` output.
This pattern is typically used to set parameters for subsequent `load()` calls.

### `load({ cache = false } = {})`

This method should return an object containing:

- `matrix`, a [`MultiMatrix`](https://kanaverse.github.io/scran.js/MultiMatrix.html) object containing submatrices for at least one modality.
  Each modality-specific submatrix should be a [`ScranMatrix`](https://kanaverse.github.io/scran.js/ScranMatrix.html) containing any number of rows.
  All modalities should contain data for the same number of columns.
  Unlike in the `Dataset` interface, there is no requirement that modalities follow particular naming schemes;
  however, they should be consistent with the output of `summary()`.
- `features`, an object where each key is the name of a modality in `matrix`.
  Each modality-specific value is a `DataFrame` with one row per feature in the corresponding entry of `matrix`.
  Rows of `features[<modality>]` should be in the same order as the rows of `matrix.get(<modality>)`.
  Columns should be per-feature annotation fields, as described for `summary()`.
- `cells`, a `DataFrame` containing one row per cell.   
  Each column should contain an array of per-cell information, corresponding to the same order of columns in each entry of `matrix`.
- `reduced_dimensions`, an object containing the dimensionality reduction results.
  Each key is the name of a result while each value is an Array of Float64Arrays, one per dimension.
  Each Float64Array should contain the coordinates of each cell along its dimension.
- `other_metadata`: an object containing additional arbitrary metadata for the `Result`.

Alternatively, this method may return a promise that resolves to such an object.

If `cache = true`, any artifacts generated by `load()` may be cached for re-use in the subsequent calls to the same method or `summary()`.
This allows for faster repeated calls at the cost of increasing memory usage.
If `cache = false`, no caching should be performed and any previously cached artifacts should be removed.

### `clear()`

This method should clear all caches generated by `load()` or `summary()` when `cache = true`. 
It may be called at any time and is useful for reducing memory usage in long-running programs.
